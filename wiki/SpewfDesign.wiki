#summary Thoughts about design and future direction of SPEWF

=What about other frameworks?=

It seems like [http://erlyweb.org/ ErlyWeb] is a really good web framework for Erlang, and follows the nice Model-View-Controller separation of Rails and Rails-inspired frameworks. I understand there will soon be an Mnesia driver for it (from !ErlyDB).

My point was not to write another framework that duplicates the efforts of more mature ones, but to provide something with some more power than "default Erlang", in an Erlang-y way; that is, without particularly following the model of other frameworks (generate code) etc.

=Concepts=

==Sessions are Processes==

The "traditional" way to keep sessions are in some kind of memory object in the language runtime system (e.g. continuations in Arc, PLT Scheme, Seaside, beans in J2EE application servers) or in a session server of some kind (a database, memcached, perhaps shared).

The disadvantages of the former are that an application scales only to a single computer. Once you have enough traffic that that becomes problematic, you now face a new problem, which means you need to start doing sessions in an entirely different way.

The second method is only a little better. It's better because the resource that is serving session information can be dedicated to that task. But it is still a potential bottleneck, either as a single point of failure or as a limiting resource.

Erlang processes as sessions have a number of advantages:

  * Scalability. A distributed Erlang system can have any number of nodes in it, each with thousands of processes executing user sessions. Since the SPEWF session id is just a process id, no dictionary or central store of session data is required--it just sends the request to the right process and sends the result back to the client.
  * Elegance. A web application never needs to worry about statefulness or concurrency. It can be written in the same way as an event-driven desktop application. Any method the programmer might want to use to preserve state (a looping function, a table, a database, whatever) can be used in a straightforward manner just as with any Erlang application.
  * Robustness. Since Erlang has online code upgrades, the user session can remain alive even as the application code it's executing is upgraded.

==Callbacks==

Erlang OTP design principles give us the notion of modules implementing standard behaviors by implementing callback functions. Although the first sketch of SPEWF combines this (so that SPEWF applications only implement the one callback), eventually there will probably be two concepts: the SPEWF handler, which is a sort of protocol adapter converting HTTP conversations into Erlang messages; and the generic session, a sort of generic server that listens to and replies to Erlang messages.

==Erlang is Cool==

Erlang is a good programming language with a robust and richly-featured runtime system. Interoperability (with database or other backends) is a general application development issue and not the responsibility of the web framework. The assumption behind SPEWF (if there is one) is that you will store your data in Mnesia. To that end, it might gain features like using Mnesia record shapes for communicating with applications, but no tighter coupling would be contemplated.

Parse transforms are neat, and if there's a way to write the web application more concisely using transformations, that would be good. However, in my opinion code generation is a no-no.

Similarly, I'm not fond of template-based frameworks. HTML is something you should generate, not write (I'm with Seaside et al. on this one). Smart "templates" should take the form of an Erlang term structure, not text files.

=Future Ideas=

It would be nice to be tighter about the "reply language" (which right now is an *ehtml* tuple, a la yaws, postprocessed) so that SPEWF can more easily insert the spid (session process id); and so that more HTML can be generated. It would be nice to do something like:

{{{
   handle([], R) ->
      {spewf, {prompt, [], said}};
   .
   .
   .
}}}

...and have SPEWF transform that into:

{{{
   {ehtml, {form, [{action, self}], [
      {input, [{type, "text"}, {name, "said"}], []}
      {input, [{type, "hidden"}, {name, 
      ]}}
}}}


Another thing would be to have a more efficient (in terms of expression) way of communicating the request to the session. Right now it's a keylist (it could be some other mapping implementation). It might be nice to have them be records defined by the callback module or something. So the request data is tuplified and sent that way.

Instead of:

{{{
   handle(S, R) ->
      case lists:keysearch(age, 1, R) of
         {value, {age, Age}} -> {S#said{age = Age}, {html, "ok"}};
         false ->
            case lists:keysearch(birthyear, 1, R) of
               {value, {birthyear, Value}} ->
                  {S#myapp{age = (?currentyear - list_to_integer(Value))}, {html, "ok"}};
      .
      .
      .
}}}

...you could have something more like:

{{{
   handle(S, #myapp{age = null, birthyear = Birthyear}) ->
      {S#myapp{age = (?currentyear - list_to_integer(Birthyear))}, {html, "ok"}};
   handle(S, #myapp{age = Age}) ->
      {S#myapp{age = Age}, {html, "ok"}};
   .
   .
   .
}}}

...which seems more concise and Erlang-y to me.